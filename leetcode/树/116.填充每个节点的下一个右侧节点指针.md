给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
 int val;
 Node *left;
  Node *right;
 Node *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 示例：
// 输入：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"ri
//ght":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right
//":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left"
//:null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":nu
//ll,"next":null,"right":null,"val":7},"val":3},"val":1}
//
//输出：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4
//","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next"
//:null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":
//null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":
//"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"va
//l":1}
解释：给定二叉树，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点
看到关于二叉树的问题，首先要想到关于二叉树的一些常见遍历方式，
对于二叉树的遍历有
前序遍历
中序遍历
后续遍历
深度优先搜索（DFS）
宽度优先搜索（BFS）
除了上面介绍的5种以外，还有Morris（莫里斯）的前中后3种遍历方式，总共也就这8种。所以只要遇到二叉树相关的算法题，首先想到的就是上面的几种遍历方式，然后再稍加修改，基本上也就这个套路。
复杂度分析
时间复杂度：O(N)，每个节点只访问一次。
空间复杂度：O(1)，不需要存储额外的节点。

递归
class Solution {
    fun connect(root: Node?): Node? {
        dfs(root,null)
        return root
    }

    fun dfs(root: Node?,next: Node?){
        if (root == null)return
        root.next = next
        dfs(root.left,root.right)
        if (root.next == null) {
            dfs(root.right,null)
        }else{
            dfs(root.right,root.next?.left)
        }
    }
}

宽度优先搜索（BFS）
//    fun connect(root: Node?): Node? {
//        if (root == null) return root
//        var temp = root
//        while (temp?.left!=null){
//            var tempRoot = temp
//            while (tempRoot!=null){
//                tempRoot.left?.next = temp.right
//                if (tempRoot.next!=null){
//                    tempRoot.right?.next = tempRoot.next?.left
//                }
//                tempRoot = tempRoot.next
//            }
//            temp = temp.left
//        }
//        return temp
//    }

