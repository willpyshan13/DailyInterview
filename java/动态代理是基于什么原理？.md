反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。

动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。

实现动态代理的方式很多，比如 JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。

1. 反射机制及其演进对于 Java 语言的反射机制本身，如果你去看一下 java.lang 或 java.lang.reflect 包下的相关抽象，就会有一个很直观的印象了。Class、Field、Method、Constructor 等，这些完全就是我们去操作类和对象的元数据对应。反射各种典型用例的编程，相信有太多文章或书籍进行过详细的介绍，我就不再赘述了，至少你需要掌握基本场景编程，这里是官方提供的参考文档：https://docs.oracle.com/javase/tutorial/reflect/index.html 。关于反射，有一点我需要特意提一下，就是反射提供的 AccessibleObject.setAccessible​(boolean flag)。它的子类也大都重写了这个方法，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在运行时修改成员访问限制！setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。

2. 动态代理前面的问题问到了动态代理，我们一起看看，它到底是解决什么问题？首先，它是一个代理机制。如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。其实很多动态代理场景，我认为也可以看作是装饰器（Decorator）模式的应用，我会在后面的专栏设计模式主题予以补充。通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面。

代理的发展经历了静态到动态的过程，源于静态代理引入的额外工作。类似早期的 RMI 之类古董技术，还需要 rmic 之类工具生成静态 stub 等各种文件，增加了很多繁琐的准备工作，而这又和我们的业务逻辑没有关系。利用动态代理机制，相应的 stub 等类，可以在运行时生成，对应的调用操作也是动态完成，极大地提高了我们的生产力。改进后的 RMI 已经不再需要手动去准备这些了，虽然它仍然是相对古老落后的技术，未来也许会逐步被移除。

JDK Proxy 的优势：

最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。

平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。

代码实现简单。

基于类似 cglib 框架的优势：有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。只操作我们关心的类，而不必为其他相关类增加工作量。高性能。


AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。


反射与动态代理原理

1 关于反射
反射最大的作用之一就在于我们可以不在编译时知道某个对象的类型，而在运行时通过提供完整的”包名+类名.class”得到。注意：不是在编译时，而是在运行时。

功能：
•在运行时能判断任意一个对象所属的类。
•在运行时能构造任意一个类的对象。
•在运行时判断任意一个类所具有的成员变量和方法。
•在运行时调用任意一个对象的方法。
说大白话就是，利用Java反射机制我们可以加载一个运行时才得知名称的class，获悉其构造方法，并生成其对象实体，能对其fields设值并唤起其methods。

应用场景：
反射技术常用在各类通用框架开发中。因为为了保证框架的通用性，需要根据配置文件加载不同的对象或类，并调用不同的方法，这个时候就会用到反射——运行时动态加载需要加载的对象。

特点：
由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。

2 动态代理
为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在两者之间起到中介的作用（可类比房屋中介，房东委托中介销售房屋、签订合同等）。
所谓动态代理，就是实现阶段不用关心代理谁，而是在运行阶段才指定代理哪个一个对象（不确定性）。如果是自己写代理类的方式就是静态代理（确定性）。

组成要素：
(动态)代理模式主要涉及三个要素：
其一：抽象类接口
其二：被代理类（具体实现抽象接口的类）
其三：动态代理类：实际调用被代理类的方法和属性的类

实现方式:
实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了反射机制。还有其他的实现方式，比如利用字节码操作机制，类似 ASM、CGLIB（基于 ASM）、Javassist 等。
举例，常可采用的JDK提供的动态代理接口InvocationHandler来实现动态代理类。其中invoke方法是该接口定义必须实现的，它完成对真实方法的调用。通过InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。此外，我们常可以在invoke方法实现中增加自定义的逻辑实现，实现对被代理类的业务逻辑无侵入。

* java是静态的强类型语言，因为也提供了反射等机制，也具备动态类型语言的能力。
>要理解动态代理需要先了解几个方面：

### 反射机制 java.lang.reflect
* 解释：运行时程序的自省。通过运行时操作元数据和对象，java可以灵活地操作运行时才能确定的信息。
* 作用
    * 使用反射可以直接操作对象
    * 获取某个对象的类定义
    * 获取类声明属性和方法
    * 调用方法或者构造对象
    * 运行时修改类定义
* 缺点：
    * 性能：能不用反射实现的需求则尽可能避免使用。性能低。
    * 安全：反射需要运行时权限，在安全管理器（SecurityManager）下可能不能运行
    * 内部接触：反射可以访问private因此可能导致副作用，破坏可移植性，打破抽象
* 场景：动态代理（AOP、RPC）、第三方开发者扩展能力、第三方组件创建对象。
* 用法：
```java
Class clazz = Class.forName("com.playcrab.war.gvg.gvgLogic");
Constructor[] conArray = clazz.getConstructors(); //获取所有公有构造方法
```

### RPC（Remote procedure call）
* 一种编程模型，不限制底层实现（RMI、网络httpClient/socket、动态代理、反射）
* 远程过程调用，多用在分布式部署中，将某个模块部署到独立服务器上，通过RPC实现客户端无感知的各服务之间的调用。比如阿里的Dubbo
* [简书-RPC介绍](https://www.jianshu.com/p/2accc2840a1b)

### AOP（Aspect Oriented Programming）
* 面相切面编程，对象与对象之间、模块与模块之间都是一个切面。减少代码量的一种方式，是OOP的一个延续。所以通过动态代理也可以实现AOP编程。Spring AOP
* 大幅提高代码的抽象度和复用度，让我们从繁琐的事项中抽身出来。

### 动态代理
* 实现方式：JDK自身提供的动态代理（java.lang.reflect.Proxy）利用了反射、高性能的字节码操作机制类似ASM、cglib、javaassist等。
* 场景：包装RPC调用、面向切面编程AOP等。
* 区别与优势：
    * JDK Proxy
        1. 被调用者必须实现接口。
        2. JDK本身支持可能更加可靠
        3. 代码实现简单。
        4. 平滑升级JDK，而字节码类库需要进行更新以保证可用。
        5. 新版本JDK也使用ASM提高性能。
    * 类cglib
        1. cglib没有实现接口的限制
        2. 只操作我们关心的类，不需要为其他相关类增加工作量
        3. 基于ASM字节码，高性能。
        4. 通过生成业务类的子类作为代理类。
* 类似python重写__getattr__、php的魔术方法__call 将对象中不同的方法统一到一个处理函数。对于调用者毫无察觉，和调用本地方法一般，被代理的类不一定是本地类，也可以通过抽象方式代理远程主机上的类，实现RPC。
* 也可以自己实现业务类的代理类，比较繁琐需要挨个实现每个方法的转发。称为静态代理

